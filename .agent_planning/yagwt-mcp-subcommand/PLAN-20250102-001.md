# Implementation Plan: yagwt mcp Subcommand

**Created**: 2025-01-02T00:00:00Z
**Target**: Add `yagwt mcp` subcommand for managing .mcp.json configuration files

## Overview

This plan describes the implementation of a new `yagwt mcp` subcommand that will manage MCP (Model Context Protocol) configuration files. The command will add or remove the yagwt MCP server configuration from a `.mcp.json` file in the current directory.

## Requirements Recap

- Subcommand: `yagwt mcp` (default: add yagwt MCP configuration)
- Option: `--rm` to remove yagwt MCP configuration
- Create `.mcp.json` if it doesn't exist
- Preserve existing configurations
- Don't modify invalid JSON files (unless empty/whitespace)
- Validate resulting JSON is valid

## Architecture Approach

### 1. Command Structure

Following the existing yagwt pattern:
- File: `internal/cli/commands/mcp.go`
- Command variable: `mcpCmd`
- Integration: Add to rootCmd in `root.go`
- Follows same flag handling and error patterns

### 2. Core Components

#### A. MCP Configuration Structure
```go
type MCPConfig struct {
    McpServers map[string]MCPServerConfig `json:"mcpServers"`
}

type MCPServerConfig struct {
    Command string        `json:"command"`
    Args    []string      `json:"args"`
    Env     []string      `json:"env,omitempty"`
}
```

#### B. YAGWT MCP Configuration
```go
func getYagwtMCPConfig() MCPServerConfig {
    return MCPServerConfig{
        Command: "./yagwt",
        Args:    []string{"mcp-server"},
        // Optional: Add environment variables if needed
    }
}
```

### 3. Implementation Phases

#### Phase 1: Command Structure and Flags
1. Create `internal/cli/commands/mcp.go`
2. Define command structure with Cobra
3. Add `--rm` flag
4. Register command in `root.go`

#### Phase 2: File Operations
1. Implement `.mcp.json` file detection and reading
2. Handle file creation if missing
3. Validate JSON structure before modification
4. Implement JSON parsing and marshaling with proper error handling

#### Phase 3: Configuration Management
1. Add yagwt MCP server configuration:
   - Check if yagwt already configured
   - Merge with existing configurations
   - Preserve order and formatting where possible
2. Remove yagwt MCP server configuration:
   - Remove yagwt entry from mcpServers map
   - Handle empty mcpServers case
   - Clean up if file becomes empty

#### Phase 4: Validation and Error Handling
1. Validate JSON before and after modifications
2. Handle edge cases:
   - File exists but is empty/whitespace
   - File exists but contains invalid JSON (warn, don't modify)
   - File permissions issues
   - Disk space issues
3. Provide user-friendly error messages

#### Phase 5: Testing
1. Unit tests for all operations
2. Integration tests with various file states
3. Error condition testing
4. Manual verification of generated .mcp.json files

## Detailed Implementation Steps

### Step 1: Create Command File (`internal/cli/commands/mcp.go`)

```go
package commands

import (
    "encoding/json"
    "fmt"
    "os"
    "path/filepath"

    "github.com/spf13/cobra"
)

var (
    mcpRemove bool
)

var mcpCmd = &cobra.Command{
    Use:   "mcp",
    Short: "Manage MCP configuration in .mcp.json",
    Long: `Manage the Model Context Protocol (MCP) configuration for yagwt.

By default, adds yagwt MCP server configuration to .mcp.json in the current directory.
Use --rm to remove the yagwt configuration.`,
    Run: runMCP,
}

func init() {
    mcpCmd.Flags().BoolVar(&mcpRemove, "rm", false, "Remove yagwt MCP configuration")
}

func runMCP(cmd *cobra.Command, args []string) {
    // Implementation here
}
```

### Step 2: Define Configuration Structures

```go
// MCPConfig represents the root structure of .mcp.json
type MCPConfig struct {
    McpServers map[string]MCPServerConfig `json:"mcpServers"`
}

// MCPServerConfig represents an MCP server configuration
type MCPServerConfig struct {
    Command string        `json:"command"`
    Args    []string      `json:"args"`
    Env     []string      `json:"env,omitempty"`
}

// getYagwtMCPConfig returns the yagwt MCP server configuration
func getYagwtMCPConfig() MCPServerConfig {
    // Determine the path to yagwt binary
    yagwtPath := "yagwt" // Default to assuming yagwt is in PATH

    // Try to get the path to the current binary if running as yagwt
    if execPath, err := os.Executable(); err == nil {
        yagwtPath = execPath
    }

    return MCPServerConfig{
        Command: yagwtPath,
        Args:    []string{"mcp-server"},
    }
}
```

### Step 3: Implement File Operations

```go
// readMCPConfig reads and parses the .mcp.json file
func readMCPConfig(filename string) (*MCPConfig, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        if os.IsNotExist(err) {
            return &MCPConfig{McpServers: make(map[string]MCPServerConfig)}, nil
        }
        return nil, fmt.Errorf("failed to read %s: %w", filename, err)
    }

    // Check if file is empty or whitespace only
    if len(bytes.TrimSpace(data)) == 0 {
        return &MCPConfig{McpServers: make(map[string]MCPServerConfig)}, nil
    }

    var config MCPConfig
    if err := json.Unmarshal(data, &config); err != nil {
        return nil, fmt.Errorf("invalid JSON in %s: %w", filename, err)
    }

    // Ensure McpServers map exists
    if config.McpServers == nil {
        config.McpServers = make(map[string]MCPServerConfig)
    }

    return &config, nil
}

// writeMCPConfig writes the MCP configuration to file with pretty printing
func writeMCPConfig(filename string, config *MCPConfig) error {
    data, err := json.MarshalIndent(config, "", "  ")
    if err != nil {
        return fmt.Errorf("failed to marshal MCP config: %w", err)
    }

    // Ensure directory exists
    dir := filepath.Dir(filename)
    if err := os.MkdirAll(dir, 0755); err != nil {
        return fmt.Errorf("failed to create directory: %w", err)
    }

    // Write with proper permissions
    if err := os.WriteFile(filename, data, 0644); err != nil {
        return fmt.Errorf("failed to write %s: %w", filename, err)
    }

    return nil
}
```

### Step 4: Implement Add/Remove Logic

```go
// addYagwtMCPConfig adds yagwt to the MCP configuration
func addYagwtMCPConfig(config *MCPConfig) bool {
    const yagwtServerName = "yagwt"

    if _, exists := config.McpServers[yagwtServerName]; !exists {
        config.McpServers[yagwtServerName] = getYagwtMCPConfig()
        return true
    }
    return false
}

// removeYagwtMCPConfig removes yagwt from the MCP configuration
func removeYagwtMCPConfig(config *MCPConfig) bool {
    const yagwtServerName = "yagwt"

    if _, exists := config.McpServers[yagwtServerName]; exists {
        delete(config.McpServers, yagwtServerName)
        return true
    }
    return false
}
```

### Step 5: Implement Main Command Logic

```go
func runMCP(cmd *cobra.Command, args []string) {
    initFormatter()

    const mcpConfigFile = ".mcp.json"

    // Check if file exists and has content
    if _, err := os.Stat(mcpConfigFile); err == nil {
        // File exists, check if it's valid JSON
        if data, err := os.ReadFile(mcpConfigFile); err == nil {
            if len(bytes.TrimSpace(data)) > 0 {
                var test interface{}
                if json.Unmarshal(data, &test) != nil {
                    fmt.Fprintf(os.Stderr, "Error: %s exists but contains invalid JSON\n", mcpConfigFile)
                    fmt.Fprintf(os.Stderr, "Please fix the JSON or remove the file manually\n")
                    os.Exit(ExitFailure)
                }
            }
        }
    }

    // Read current configuration
    config, err := readMCPConfig(mcpConfigFile)
    if err != nil {
        handleError(fmt.Errorf("failed to read MCP configuration: %w", err))
        return
    }

    var changed bool
    var action string

    if mcpRemove {
        changed = removeYagwtMCPConfig(config)
        action = "removed"
    } else {
        changed = addYagwtMCPConfig(config)
        action = "added"
    }

    if !changed {
        if mcpRemove {
            printOutput(formatter.FormatInfo("yagwt MCP configuration not found in .mcp.json"))
        } else {
            printOutput(formatter.FormatInfo("yagwt MCP configuration already exists in .mcp.json"))
        }
        return
    }

    // Write updated configuration
    if err := writeMCPConfig(mcpConfigFile, config); err != nil {
        handleError(fmt.Errorf("failed to write MCP configuration: %w", err))
        return
    }

    // Validate the written file
    if data, err := os.ReadFile(mcpConfigFile); err == nil {
        var test interface{}
        if json.Unmarshal(data, &test) != nil {
            fmt.Fprintf(os.Stderr, "Error: Wrote invalid JSON to %s\n", mcpConfigFile)
            os.Exit(ExitFailure)
        }
    }

    printOutput(formatter.FormatSuccess(fmt.Sprintf("yagwt MCP configuration %s to .mcp.json", action)))
}
```

### Step 6: Update Root Command

In `internal/cli/commands/root.go`, add the new command to the `init()` function:

```go
func init() {
    // ... existing flags ...

    // Add subcommands
    rootCmd.AddCommand(versionCmd)
    rootCmd.AddCommand(lsCmd)
    // ... existing commands ...
    rootCmd.AddCommand(doctorCmd)
    rootCmd.AddCommand(mcpCmd)  // Add this line

    // ... rest of init() ...
}
```

## Testing Strategy

### Unit Tests

File: `internal/cli/commands/mcp_test.go`

Test cases:
1. **Add configuration to new file**
   - File doesn't exist
   - Creates file with correct structure
   - Contains only yagwt configuration

2. **Add configuration to existing file**
   - File exists with other configurations
   - Adds yagwt without modifying others
   - Preserves formatting and structure

3. **Add when already exists**
   - yagwt already configured
   - Shows appropriate message
   - Doesn't modify file

4. **Remove configuration**
   - File exists with yagwt configured
   - Removes yagwt entry
   - Preserves other configurations

5. **Remove when not found**
   - File exists without yagwt
   - Shows appropriate message
   - Doesn't modify file

6. **Handle empty/whitespace file**
   - File exists but is empty
   - Treats as new configuration
   - Creates valid structure

7. **Handle invalid JSON**
   - File exists with invalid JSON
   - Shows error message
   - Doesn't modify file

8. **Handle permission errors**
   - Simulate read/write permission issues
   - Shows appropriate error messages

### Integration Tests

1. **End-to-end workflow**
   - Run `yagwt mcp` in empty directory
   - Verify .mcp.json is created correctly
   - Run `yagwt mcp --rm`
   - Verify yagwt is removed but file structure remains

2. **Multiple MCP servers**
   - Create .mcp.json with multiple servers
   - Add yagwt
   - Verify all servers present

3. **Binary path resolution**
   - Test with yagwt in PATH
   - Test with relative path to binary
   - Verify correct command in config

## Error Handling

### Expected Error Conditions

1. **File system errors**
   - Permission denied reading/writing
   - Disk full
   - Invalid path

2. **JSON parsing errors**
   - Invalid JSON in existing file
   - Marshaling failures

3. **Configuration errors**
   - Binary not found
   - Invalid command structure

### Error Messages

Use the existing error handling patterns from yagwt:
- `ExitFailure` for general failures
- `ExitInvalidUsage` for invalid arguments
- Human-readable error messages
- Suggestions for resolution

## Output Formatting

Follow yagwt's output patterns:
- Use `formatter.FormatSuccess()` for success messages
- Use `formatter.FormatInfo()` for informational messages
- Use `formatter.FormatError()` for errors
- Respect `--json`, `--porcelain`, and `--quiet` flags

## Dependencies

No additional dependencies required:
- Uses standard `encoding/json`
- Uses existing `github.com/spf13/cobra`
- Uses existing yagwt error handling and output formatting

## Completion Criteria

- [ ] Command added to yagwt and accessible
- [ ] Adds yagwt MCP configuration to .mcp.json
- [ ] Removes yagwt MCP configuration with --rm flag
- [ ] Creates .mcp.json if it doesn't exist
- [ ] Preserves existing MCP configurations
- [ ] Doesn't modify files with invalid JSON
- [ ] Validates JSON after writing
- [ ] Handles all error conditions gracefully
- [ ] Follows yagwt's CLI patterns and conventions
- [ ] Unit tests with >90% coverage
- [ ] Integration tests verify end-to-end functionality
- [ ] Documentation updated

## Future Considerations

1. **Configuration Templates**
   - Allow users to specify custom command arguments
   - Support for environment variables

2. **Multiple YAGWT Instances**
   - Support for multiple yagwt server configurations
   - Named configurations

3. **Validation**
   - Verify the MCP server can actually start
   - Test configuration before writing

4. **Integration with other tools**
   - Auto-detect other MCP-compatible tools
   - Suggest configurations

## Risks and Mitigations

1. **Risk**: Modifying .mcp.json could break other MCP clients
   **Mitigation**: Always validate JSON, preserve existing configs, refuse to modify invalid JSON

2. **Risk**: Binary path resolution issues
   **Mitigation**: Default to simple "yagwt" in PATH, allow manual override in future

3. **Risk**: File permission issues
   **Mitigation**: Clear error messages with suggestions for resolution

4. **Risk**: Concurrent modifications
   **Mitigation**: Read-modify-write with proper error handling if file changes between read and write