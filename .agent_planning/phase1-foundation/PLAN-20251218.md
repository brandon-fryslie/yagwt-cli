# Phase 1: Foundation - Implementation Plan

**Topic**: Foundation (Core Infrastructure)
**Created**: 2024-12-18
**Status**: Ready for Implementation

## Overview

Phase 1 establishes the core infrastructure for YAGWT. All higher-level functionality depends on these foundational components working correctly.

## Components to Implement

### 1. Git Wrapper (`internal/git/`)

**Current State**: Interface defined, stub implementation returns empty values

**Required Implementation**:

#### 1.1 Repository Detection
- Implement `NewRepository(path)` to:
  - Find repo root from any path within repo (use `git rev-parse --show-toplevel`)
  - Detect git directory (`.git` file for worktrees, `.git` dir for main)
  - Handle bare repos (error - we don't support them)
  - Return E_GIT error if not in a git repo

#### 1.2 Worktree Listing
- Implement `ListWorktrees()`:
  - Execute `git worktree list --porcelain`
  - Parse porcelain output format:
    ```
    worktree /path/to/worktree
    HEAD abc123...
    branch refs/heads/feature-x

    worktree /path/to/another
    HEAD def456...
    detached
    ```
  - Handle locked worktrees (additional `locked` line)
  - Handle prunable worktrees (additional `prunable` line)
  - Return structured `[]Worktree`

#### 1.3 Worktree Operations
- Implement `AddWorktree(path, ref, opts)`:
  - Build command: `git worktree add [opts] <path> <ref>`
  - Handle `--track` for new branches with upstream
  - Handle `--detach` for commits
  - Handle `--force` for overwriting
  - Parse error output for meaningful errors

- Implement `RemoveWorktree(path, force)`:
  - Execute `git worktree remove <path>`
  - Handle `--force` flag
  - Parse errors (locked, dirty, missing)

#### 1.4 Status Operations
- Implement `GetStatus(path)`:
  - Execute `git -C <path> status --porcelain=v2 --branch`
  - Parse v2 format for:
    - Branch name (`# branch.head`)
    - Upstream tracking (`# branch.upstream`, `# branch.ab`)
    - Modified files (`1 .M ...`, `? ...`, etc.)
    - Conflicts (`u ...`)
  - Return structured `Status`

#### 1.5 Reference Operations
- Implement `ResolveRef(ref)`:
  - Execute `git rev-parse --verify <ref>`
  - Return full SHA
  - Handle invalid refs with E_NOT_FOUND

- Implement `GetBranch(ref)`:
  - Get branch details (name, upstream, HEAD)
  - Use `git for-each-ref` or similar

### 2. Metadata Storage (`internal/metadata/`)

**Current State**: Interface defined, stub returns empty metadata

**Required Implementation**:

#### 2.1 Store Initialization
- Implement `NewStore(gitDir)`:
  - Create path: `<gitDir>/yagwt/meta.json`
  - Create directory if missing
  - Handle permissions errors

#### 2.2 Load Operations (Lock-Free)
- Implement `Load()`:
  - Read JSON file
  - Handle missing file (return empty metadata with schema v1)
  - Handle corrupted JSON (E_CONFIG error)
  - Validate schema version

- Implement `Get(id)`, `FindByName(name)`, `FindByPath(path)`:
  - Load metadata
  - Use index for O(1) lookups
  - Return E_NOT_FOUND if not present

#### 2.3 Save Operations (Require Lock)
- Implement atomic writes:
  - Write to temp file first
  - Rename atomically
  - Handle disk full / permission errors

- Implement `Save(metadata)`:
  - Full metadata replacement
  - Update all indexes

- Implement `Set(id, meta)`:
  - Single workspace update
  - Update indexes appropriately

- Implement `Delete(id)`:
  - Remove workspace
  - Clean up index entries

#### 2.4 Index Operations
- Implement `RebuildIndex()`:
  - Walk all workspaces
  - Rebuild `ByPath`, `ByName`, `ByBranch` indexes
  - Detect and warn about duplicates

### 3. Lock Manager (`internal/lock/`)

**Current State**: Interface defined, stub does nothing

**Required Implementation**:

#### 3.1 File Lock Creation
- Implement `NewLock(path)`:
  - Create lock file path (don't create file yet)
  - Ensure parent directory exists

#### 3.2 Lock Acquisition
- Implement `Acquire(timeout)`:
  - Open/create lock file
  - Use `syscall.Flock` (Linux) or `syscall.FcntlFlock` (macOS/portable)
  - Implement timeout with polling or select
  - Return E_LOCKED on timeout
  - Store file descriptor for release

#### 3.3 Lock Release
- Implement `Release()`:
  - Release flock
  - Close file descriptor
  - Optionally remove lock file (or leave for reuse)

### 4. Config Loader (`internal/config/`)

**Current State**: Returns defaults, doesn't load files

**Required Implementation**:

#### 4.1 Config File Discovery
- Search in order (first found wins):
  1. `--config <path>` (passed to Load)
  2. `<repoRoot>/.yagwt/config.toml`
  3. macOS: `~/Library/Application Support/yagwt/config.toml`
  4. Linux/fallback: `~/.config/yagwt/config.toml` or `$XDG_CONFIG_HOME/yagwt/config.toml`

#### 4.2 TOML Parsing
- Use `github.com/BurntSushi/toml` or `github.com/pelletier/go-toml/v2`
- Parse config file
- Merge with defaults (config overrides defaults)

#### 4.3 Validation
- Validate `rootStrategy` is "sibling" or "inside"
- Validate `onDirty` is valid value
- Validate durations can be parsed
- Return E_CONFIG on invalid config

### 5. Error Model (`internal/core/`)

**Current State**: Basic error type exists, needs enhancements

**Required Implementation**:

#### 5.1 Error Wrapping
- Add ability to wrap underlying errors
- Preserve error chain for debugging

#### 5.2 JSON Serialization
- Ensure errors serialize correctly for `--json` output
- Include all fields in JSON envelope

## Testing Strategy

### Unit Tests

Each component needs unit tests:

1. **Git Wrapper Tests** (`internal/git/repo_test.go`):
   - Test porcelain parsing (mock command output)
   - Test error handling for various git failures
   - Use table-driven tests for parsing

2. **Metadata Tests** (`internal/metadata/store_test.go`):
   - Test CRUD operations
   - Test atomic writes (simulate crashes)
   - Test index rebuilding
   - Test schema migration (future-proofing)

3. **Lock Tests** (`internal/lock/lock_test.go`):
   - Test acquire/release cycle
   - Test timeout behavior
   - Test concurrent acquisition

4. **Config Tests** (`internal/config/config_test.go`):
   - Test file discovery order
   - Test TOML parsing
   - Test defaults merging
   - Test validation errors

### Integration Tests

Create `internal/git/integration_test.go`:
- Create temp git repos
- Actually run git commands
- Test worktree creation/removal
- Test status parsing with real dirty state

## Dependencies to Add

```go
// go.mod additions
require (
    github.com/pelletier/go-toml/v2 v2.x.x  // TOML parsing
    github.com/google/uuid v1.x.x           // For generating workspace IDs
)
```

## File Changes Summary

| File | Change Type | Description |
|------|-------------|-------------|
| `internal/git/repo.go` | Modify | Full implementation |
| `internal/git/repo_test.go` | Create | Unit tests |
| `internal/git/integration_test.go` | Create | Integration tests |
| `internal/metadata/store.go` | Modify | Full implementation |
| `internal/metadata/store_test.go` | Create | Unit tests |
| `internal/lock/lock.go` | Modify | Full implementation |
| `internal/lock/lock_test.go` | Create | Unit tests |
| `internal/config/config.go` | Modify | Full implementation |
| `internal/config/config_test.go` | Create | Unit tests |
| `internal/core/errors.go` | Modify | Add wrapping |
| `go.mod` | Modify | Add dependencies |

## Implementation Order

1. **Error model enhancements** (needed by everything)
2. **Lock manager** (needed by metadata)
3. **Git wrapper** (can be tested independently)
4. **Metadata storage** (depends on lock)
5. **Config loader** (depends on nothing, but useful last)

This order minimizes interdependencies during development.

## Success Criteria

See `DOD-20251218.md` for acceptance criteria.
