# Phase 2: Core Engine - Implementation Plan

**Topic**: Core Engine (Business Logic)
**Created**: 2024-12-18
**Status**: Ready for Implementation

## Overview

Phase 2 implements the WorkspaceManager - the central business logic layer that orchestrates git operations with metadata management. This is the heart of YAGWT, providing CRUD operations for workspaces with proper lifecycle tracking.

## Components to Implement

### 1. Engine Initialization (`internal/core/engine.go`)

**Current State**: Stub engine with placeholder methods

**Required Implementation**:

#### 1.1 Dependency Injection
- Refactor `engine` struct to accept dependencies:
  ```go
  type engine struct {
      repo     git.Repository
      store    metadata.Store
      config   config.Config
      lockPath string
  }
  ```
- Create `NewEngine(path string) (WorkspaceManager, error)`:
  - Find git repo from path
  - Create metadata store
  - Load config
  - Return initialized engine
- Create `NewEngineWithDeps(repo, store, config)` for testing

### 2. Selector System (`internal/core/selector.go`)

**Current State**: Stub ParseSelector returns bare selector

**Required Implementation**:

#### 2.1 Selector Parsing
- Parse prefix syntax: `id:`, `name:`, `path:`, `branch:`
- Handle bare values (no prefix)
- Normalize paths (make absolute, clean)

#### 2.2 Selector Resolution
- Implement `Resolve(ref string) ([]Workspace, error)`:
  - Parse selector from ref
  - If typed (id:/name:/path:/branch:), lookup directly
  - If bare, try in order: id → name → path → branch
  - Return all matches (might be multiple for branch)
- Handle E_NOT_FOUND when no matches
- Return multiple for ambiguous bare selectors

#### 2.3 Workspace Resolution Helper
- Implement `resolveOne(selector) (Workspace, error)`:
  - Call Resolve()
  - If 0 results → E_NOT_FOUND
  - If 1 result → return it
  - If >1 results → E_AMBIGUOUS with hints

### 3. List Operation (`internal/core/engine.go`)

**Current State**: Returns stub error

**Required Implementation**:

#### 3.1 Workspace Merging
- Call `repo.ListWorktrees()` to get git worktrees
- Call `store.Load()` to get metadata
- Merge data:
  - For each worktree, find matching metadata by path
  - Create Workspace with merged data
  - Mark workspaces without git worktree as "broken"
  - Track metadata entries with no worktree (orphaned)

#### 3.2 Status Integration
- For each workspace, call `repo.GetStatus(path)`
- Populate StatusInfo (dirty, conflicts, ahead/behind)

#### 3.3 Primary Detection
- Detect primary workspace (the original checkout)
- Usually the worktree at repo root or the one without `.git` file

### 4. Get Operation (`internal/core/engine.go`)

**Required Implementation**:
- Parse selector
- Call Resolve() to find matches
- Return single match or appropriate error

### 5. Create Operation (`internal/core/engine.go`)

**Current State**: Returns stub error

**Required Implementation**:

#### 5.1 Path Determination
- If opts.Dir provided, use it
- Else if config.rootStrategy == "sibling":
  - Place at `<repoRoot>/../<name or branch>`
- Else if config.rootStrategy == "inside":
  - Place at `<repoRoot>/.worktrees/<name or branch>`

#### 5.2 Git Worktree Creation
- Build AddOptions from CreateOptions
- Call `repo.AddWorktree(path, target, opts)`
- Handle --detach for commits
- Handle --track for new branches with upstream

#### 5.3 Metadata Creation
- Generate UUID for workspace ID (use `github.com/google/uuid`)
- Create WorkspaceMetadata:
  - ID, Name (from opts or derive from branch)
  - Path (absolute path to worktree)
  - Flags (pinned, ephemeral from opts)
  - Ephemeral info (TTL, ExpiresAt if ephemeral)
  - Activity (CreatedAt = now)
- Acquire lock
- Save metadata

#### 5.4 Return Value
- Build Workspace from fresh status
- Return created workspace

### 6. Remove Operation (`internal/core/engine.go`)

**Current State**: Returns stub error

**Required Implementation**:

#### 6.1 Workspace Resolution
- Resolve selector to workspace
- Check if pinned → fail with E_LOCKED
- Check if locked → fail with E_LOCKED

#### 6.2 Dirty Handling
- Get status
- If dirty and opts.OnDirty == "fail" → E_DIRTY
- If dirty and opts.OnDirty == "force" → proceed
- Other strategies (stash, patch, wip-commit) → Phase 3

#### 6.3 Git Worktree Removal
- Call `repo.RemoveWorktree(path, force)`
- Handle errors (locked, dirty)

#### 6.4 Metadata Cleanup
- Acquire lock
- Delete workspace from metadata
- Save

### 7. Lifecycle Operations (`internal/core/engine.go`)

#### 7.1 Rename
- Resolve selector
- Validate new name (no duplicates)
- Acquire lock
- Update metadata name
- Update indexes
- Save

#### 7.2 Move
- Resolve selector
- Create new worktree at new path
- Copy metadata
- Remove old worktree
- Update metadata path
- Note: This is complex - may need git operations

#### 7.3 Pin/Unpin
- Resolve selector
- Acquire lock
- Update Flags.Pinned
- Save

#### 7.4 Lock/Unlock
- Resolve selector
- Acquire lock
- Update Flags.Locked
- Save

### 8. ID Generation

**Decision needed from spec**: Use UUID for workspace IDs
- Format: `wsp_<uuid-without-dashes>` or just UUID
- Implementation: `github.com/google/uuid`

## Testing Strategy

### Unit Tests

1. **Selector Tests** (`internal/core/selector_test.go`):
   - Test parsing of all selector types
   - Test path normalization
   - Table-driven tests for parsing

2. **Engine Tests** (`internal/core/engine_test.go`):
   - Mock git.Repository and metadata.Store interfaces
   - Test List merging logic
   - Test Create flow
   - Test Remove flow with various opts
   - Test lifecycle operations

### Integration Tests

Create `internal/core/integration_test.go`:
- Create temp git repos
- Actually run operations
- Verify git worktrees are created/removed
- Verify metadata is persisted

## Dependencies to Add

```go
// go.mod additions
require (
    github.com/google/uuid v1.6.0  // For workspace ID generation
)
```

## File Changes Summary

| File | Change Type | Description |
|------|-------------|-------------|
| `internal/core/engine.go` | Modify | Full implementation |
| `internal/core/engine_test.go` | Create | Unit tests |
| `internal/core/selector.go` | Modify | Full implementation |
| `internal/core/selector_test.go` | Create | Unit tests |
| `internal/core/integration_test.go` | Create | Integration tests |
| `go.mod` | Modify | Add uuid dependency |

## Implementation Order

1. **Selector system** (needed by everything)
2. **Engine initialization** (dependency injection)
3. **List operation** (needed to verify other ops work)
4. **Get operation** (uses selector system)
5. **Create operation** (core CRUD)
6. **Remove operation** (core CRUD)
7. **Lifecycle operations** (Pin/Unpin/Lock/Unlock/Rename)
8. **Move operation** (most complex, last)

This order builds incrementally - each step can be tested before moving on.

## Success Criteria

See `DOD-20251218.md` for acceptance criteria.
