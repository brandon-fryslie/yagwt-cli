# Phase 3: Advanced Features - Implementation Plan

**Topic**: Advanced Features (Cleanup, Doctor, Filters)
**Created**: 2024-12-18
**Status**: Ready for Implementation

## Overview

Phase 3 implements intelligent maintenance operations for YAGWT. These features enable automated cleanup of stale workspaces, detection and repair of broken workspaces, and flexible filtering for listing operations.

## Components to Implement

### 1. Filter Engine (`internal/filter/`)

**Purpose**: Parse and evaluate filter expressions for workspace selection

#### 1.1 Filter Types

Create a new package `internal/filter/` with:

```go
type Filter interface {
    Match(ws core.Workspace) bool
}

type FilterExpr struct {
    Filters []Filter
    Logic   string // "and" or "or"
}
```

#### 1.2 Filter Language

Support the following filter syntax:

| Filter | Syntax | Example |
|--------|--------|---------|
| Flag | `flag:<name>` | `flag:pinned`, `flag:ephemeral`, `flag:locked`, `flag:broken` |
| Status | `status:<state>` | `status:dirty`, `status:clean`, `status:conflicts` |
| Target | `target:<type>` | `target:branch`, `target:detached` |
| Activity | `activity:<condition>` | `activity:idle>30d`, `activity:active<1h` |
| Name | `name:<pattern>` | `name:feature-*` (glob pattern) |
| Branch | `branch:<pattern>` | `branch:main`, `branch:feature/*` |

#### 1.3 Parser Implementation

- Implement `ParseFilter(expr string) (Filter, error)`
- Support comma-separated filters (implicit AND)
- Support OR logic with `|` separator
- Handle quoted strings for complex patterns
- Return E_CONFIG for invalid filter syntax

#### 1.4 Evaluator Implementation

- Implement `Match(ws Workspace) bool` for each filter type
- Duration parsing for activity filters
- Glob pattern matching for name/branch filters

### 2. Cleanup Policy Engine (`internal/cleanup/`)

**Purpose**: Policy-driven identification and removal of stale workspaces

#### 2.1 Policy Types

Create `internal/cleanup/` package with:

```go
type Policy interface {
    Name() string
    Evaluate(ws core.Workspace) (RemovalReason, bool)
}

type RemovalReason struct {
    Code    string
    Message string
}
```

#### 2.2 Built-in Policies

**Default Policy** (balanced):
- Remove expired ephemeral workspaces
- Remove workspaces idle >30 days (not pinned, not dirty)
- Skip locked or pinned workspaces

**Conservative Policy**:
- Remove expired ephemeral workspaces only
- Never touch non-ephemeral workspaces

**Aggressive Policy**:
- Remove expired ephemeral workspaces
- Remove workspaces idle >7 days (not pinned)
- Remove merged branches (not on remote)

#### 2.3 Plan Generation

Implement `GeneratePlan(workspaces []Workspace, policy Policy) CleanupPlan`:
- Evaluate each workspace against policy
- Collect removal candidates with reasons
- Sort by safety (ephemeral first, then idle, then merged)
- Generate warnings for potentially risky removals

#### 2.4 Plan Execution

Integrate with core.WorkspaceManager.Remove():
- Execute removals in order
- Respect on-dirty settings
- Track partial success
- Generate summary report

### 3. On-Dirty Strategies (`internal/core/`)

**Purpose**: Safe handling of dirty workspaces during removal

#### 3.1 Strategy Types

Extend RemoveOptions to fully support:

| Strategy | Behavior |
|----------|----------|
| `fail` | Return E_DIRTY, don't remove (default) |
| `force` | Remove anyway, user accepts data loss |
| `stash` | Run `git stash` before removal |
| `patch` | Export uncommitted changes as patch file |
| `wip-commit` | Create WIP commit before removal |

#### 3.2 Implementation

Modify `engine.Remove()` to:

**stash**:
```bash
git -C <path> stash push -m "yagwt: auto-stash before removal"
```

**patch**:
```bash
git -C <path> diff HEAD > <patchDir>/<workspace-name>.patch
git -C <path> diff --cached >> <patchDir>/<workspace-name>.patch
```

**wip-commit**:
```bash
git -C <path> add -A
git -C <path> commit -m "WIP: <message or default>"
```

### 4. Doctor/Repair (`internal/core/`)

**Purpose**: Detect and repair inconsistencies between git and metadata

#### 4.1 Detection

Implement `engine.Doctor()`:

**Detect broken workspaces**:
- Metadata exists but git worktree missing
- Git worktree exists but metadata missing
- Path exists but is not a valid git worktree

**Detect orphaned metadata**:
- Workspace ID in metadata but no matching worktree

**Detect stale indexes**:
- Index entries pointing to non-existent workspaces

#### 4.2 Repair Actions

| Issue | Repair Action |
|-------|---------------|
| Metadata for missing worktree | Remove metadata entry (--forget-missing) |
| Worktree without metadata | Create metadata entry |
| Stale index entry | Rebuild indexes |
| Broken git worktree | Mark as broken in metadata |

#### 4.3 Report Generation

Return DoctorReport with:
- List of issues found
- List of repairs applied (or would-apply in dry-run)
- Warnings for issues that can't be auto-repaired

### 5. Update Cleanup and Doctor in Engine

#### 5.1 Cleanup Implementation

Replace stub in `engine.Cleanup()`:
```go
func (e *engine) Cleanup(opts CleanupOptions) (CleanupPlan, error) {
    // Load policy
    policy := cleanup.GetPolicy(opts.Policy)

    // List all workspaces
    workspaces, err := e.List(ListOptions{})

    // Generate plan
    plan := cleanup.GeneratePlan(workspaces, policy)

    // Execute if not dry-run
    if !opts.DryRun {
        for _, action := range plan.Actions {
            // Remove workspace
        }
    }

    return plan, nil
}
```

#### 5.2 Doctor Implementation

Replace stub in `engine.Doctor()`:
```go
func (e *engine) Doctor(opts DoctorOptions) (DoctorReport, error) {
    // Detect issues
    issues := e.detectIssues()

    // Apply repairs if not dry-run
    if !opts.DryRun {
        for _, issue := range issues {
            e.repairIssue(issue)
        }
    }

    return DoctorReport{...}, nil
}
```

## Testing Strategy

### Unit Tests

1. **Filter Tests** (`internal/filter/filter_test.go`):
   - Test parsing of all filter types
   - Test matching against sample workspaces
   - Table-driven tests for filter combinations
   - Error handling for invalid syntax

2. **Cleanup Tests** (`internal/cleanup/cleanup_test.go`):
   - Test each policy type
   - Test plan generation logic
   - Test edge cases (empty list, all pinned, etc.)

3. **On-Dirty Tests** (`internal/core/engine_test.go`):
   - Test stash strategy
   - Test patch strategy
   - Test wip-commit strategy
   - Test error handling

4. **Doctor Tests** (`internal/core/doctor_test.go`):
   - Test detection of all issue types
   - Test repair actions
   - Test dry-run mode

### Integration Tests

Create `internal/core/cleanup_integration_test.go`:
- Test full cleanup flow with real git repos
- Test doctor with actual broken states
- Verify no data loss in normal operations

## File Changes Summary

| File | Change Type | Description |
|------|-------------|-------------|
| `internal/filter/filter.go` | Create | Filter engine |
| `internal/filter/filter_test.go` | Create | Filter tests |
| `internal/cleanup/policy.go` | Create | Cleanup policies |
| `internal/cleanup/cleanup.go` | Create | Plan generation |
| `internal/cleanup/cleanup_test.go` | Create | Cleanup tests |
| `internal/core/engine.go` | Modify | Implement Cleanup/Doctor |
| `internal/core/engine_test.go` | Modify | Add on-dirty tests |
| `internal/core/doctor_test.go` | Create | Doctor tests |
| `internal/core/integration_test.go` | Modify | Add cleanup/doctor tests |

## Implementation Order

1. **Filter Engine** (needed by cleanup policies)
2. **Cleanup Policies** (pure logic, easy to test)
3. **On-Dirty Strategies** (needed by cleanup execution)
4. **Cleanup Plan/Execute** (integrates policies + on-dirty)
5. **Doctor Detection** (pure logic)
6. **Doctor Repair** (depends on detection)

This order allows incremental testing and builds on previous work.

## Success Criteria

See `DOD-20251218.md` for acceptance criteria.
